\section{Background}
\label{section:background}

In this section, we provide the background information on automatic software repair and present an example of fixing a software vulnerability automatically.

\subsection{Automatic software repair}

The term "automatic software repair" covers many different approaches which accept a buggy program as an input and produce a fix for the target bug as an output.
In this section, we will focus only on \GV automatic repair (e.g., GenProg~\cite{le2012systematic}, SPR~\cite{long2015staged}, Prophet~\cite{long2015prophet}); we will be using the terms \GV automatic repair and automatic repair interchangeably.
The typical workflow of a \GV automatic repair tool is depicted in the Figure~\ref{figure:repair-overview}.

\begin{figure}
    \includegraphics[width=\linewidth]{repair-overview}
    \caption{The workflow of a \GV automatic repair tool}
    \label{figure:repair-overview}
\end{figure}

Along with a buggy program, a \GV tool also accepts two types of test cases:
\begin{itemize}
    \item \textbf{Positive} test cases that verify the existing program's functionality and
    \item \textbf{Negative} test cases that expose the \emph{target} bug (i.e., the bug that the tool aims to fix)
\end{itemize}

The first step is the stage of \emph{fault localization} that produces a ranked list of statements that are considered to be buggy. Fault localization is a well-established area of Software engineering~\cite{wong2009survey} with many different approaches; the approach adopted by many automatic repair tools is as follows: instrument each statement in the buggy program and run the program with the provided test cases. Then, based on some metric, order the statements from the most likely to be buggy to the least likely. E.g., SPR's fault localization algorithm prefers the statements that are (1) executed with more negative test cases (2) fewer positive test cases and (3) encountered later whilst executing the program with negative test cases.

After the ordered list of buggy statements is produced, an automatic repair tool applies its \emph{transformations} to attempt to fix the target bug. These transformations depend on a search space that is employed by a particular tool. To verify the correctness of the fix applied, a repairer runs all the test cases: negative ones (to verify that the bug is gone) and positive ones (to verify that no regressions are introduced). If the test cases pass, then the patch is considered correct and it is presented to the developer; otherwise, a repairer picks another fix from the search space and repeats the previous steps.

\subsection{GenProg}

GenProg~\cite{le2012systematic} is an automatic repair tools based on genetic programming (GP); it randomly creates candidate fixes and refines them through GP---by exchanging, adding or removing statements---until one of the fixes passes all the test cases. The main assumption that GenProg makes is that the program already has correct fixes for the target bug somewhere in the program; the goal is to find the fixes and apply them in the correct location. Thus, if the program does not contain ``ingredients'' for the correct fix, then the target bug cannot be repaired. In addition, Qi et al.~\cite{qi2015analysis} showed that, for the benchmarks GenProg was evaluated on, most of the fixes correspond to simple functionality deletions; they do not fix the target bug but rather just delete the functionality in which the bug resides.

\subsection{SPR and Prophet}

SPR~\cite{long2015staged} and Prophet~\cite{long2015prophet} share the same search spaces; Prophet extends SPR by a better prioritization of candidate fixes through learning from developer patches. Contrarily to GenProg, SPR's search spaces are deterministic; SPR applies its transformations in a certain order (the order is hard-coded) until either all the test cases pass or the search space is exhausted. Next, we present the transformations in the order that SPR applies them (Figure~\ref{figure:spr-repairs} shows from GenProg benchmarks on which SPR was evaluated).

\textbf{Condition refinement.} Transform an existing if-condition by adding ``\texttt{\&\& P}'' or ``\texttt{|| P}''; \texttt{P} is a new condition of the form ``\texttt{(v == const)}'' or ``\texttt{(v != const)}'', where \texttt{v} is an existing variable in the current scope.
\emph{Note:} degenerate cases that either remove the whole if-block (\texttt{\&\& 0}) or always execute the if-block (\texttt{|| 1}) are possible as well.

\textbf{Condition introduction.} Transforming an existing statement by adding an if-condition around it.

\textbf{Conditional control flow introduction.} Put a conditional control-flow statement (e.g., \texttt{break}, \texttt{continue}, \texttt{return}) before a statement.

\textbf{Insert initialization.} Put a call to \texttt{memset} before a statement.

\textbf{Value replacement} can either (1) replace a variable with another variable, (2) replace a function with another function that has the same signature or (3) replace a constant with another constant.

\textbf{Copy and replace}. Copy an existing statement before the target statement and apply \textbf{value replacement}.

\begin{figure}[t!]

\begin{subfigure}[b]{\linewidth}
    \lstinputlisting[language=diff]{resources/condition-refinement.diff}
    \vspace{-0.1in}
    \caption{Condition refinement from lighttpd-1913-1914}
\end{subfigure}

% libtiff-fix-tests-2e42d63ftools_tiffcrop.c-110
\begin{subfigure}[b]{\linewidth}
    \lstinputlisting[language=diff]{resources/condition-introduction.diff}
    \vspace{-0.1in}
    \caption{Condition introduction from libtiff-5b02179-3dfb33b}
\end{subfigure}

\begin{subfigure}[b]{\linewidth}
    \lstinputlisting[language=diff]{resources/conditional-control-flow.diff}
    \vspace{-0.1in}
    \caption{Conditional control-flow from php-308262-308315}
\end{subfigure}

\begin{subfigure}[b]{\linewidth}
    \lstinputlisting[language=diff]{resources/initialization.diff}
    \vspace{-0.1in}
    \caption{``Insert initialization'' from php-307846-307853}
\end{subfigure}

\begin{subfigure}[b]{\linewidth}
    \lstinputlisting[language=diff]{resources/value-replacement.diff}
    \vspace{-0.1in}
    \caption{Value replacement from php-307562-307561}
\end{subfigure}

\begin{subfigure}[b]{\linewidth}
    \lstinputlisting[language=diff]{resources/copy-and-replace.diff}
    \vspace{-0.1in}
    \caption{Copy-and-replace from php-308525-308529}
\end{subfigure}

\vspace{0.1in}
\small \caption{Examples of SPR transformations}
    \label{figure:spr-repairs}
\vspace{-0.2in}
\end{figure}

%\subsection{Example of fixing a vulnerability automatically}

% An example:
% how about lighttpd-bug-2661-2662
% https://redmine.lighttpd.net/projects/lighttpd/repository/1?utf8=%E2%9C%93&rev=2662
% https://redmine.lighttpd.net/issues/1551
